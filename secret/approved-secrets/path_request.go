package main

import (
	"context"
	"fmt"
	"path"
	"strings"
	"time"

	"github.com/ashwanthkumar/slack-go-webhook"
	uuid "github.com/hashicorp/go-uuid"
	"github.com/hashicorp/vault/sdk/framework"
	"github.com/hashicorp/vault/sdk/logical"
	"github.com/pkg/errors"
)

func pathRequest(b *backend) *framework.Path {
	return &framework.Path{
		Pattern: "request/" + framework.GenericNameRegex("name") + framework.OptionalParamRegex("nonce"),
		Fields: map[string]*framework.FieldSchema{
			"name": {
				Type:        framework.TypeString,
				Description: "Name of role for request.",
				Required:    true,
			},
			"nonce": {
				Type:        framework.TypeString,
				Description: "Nonce generated by request.",
				Required:    true,
			},
			"reason": {
				Type:        framework.TypeString,
				Description: "Reason for requesting secret.",
				Required:    true,
			},
		},
		ExistenceCheck: b.pathRequestExistenceCheck,
		Callbacks: map[logical.Operation]framework.OperationFunc{
			logical.DeleteOperation: b.pathRequestDelete,
			logical.ReadOperation:   b.pathRequestRead,
			logical.CreateOperation: b.pathRequestCreateUpdate,
			logical.UpdateOperation: b.pathRequestCreateUpdate,
		},
	}
}

func pathListRequest(b *backend) *framework.Path {
	return &framework.Path{
		Pattern: "request/" + framework.GenericNameRegex("name") + "/?$",
		Fields: map[string]*framework.FieldSchema{
			"name": {
				Type:        framework.TypeString,
				Description: "Name of role for sr.",
				Required:    true,
			},
		},
		Callbacks: map[logical.Operation]framework.OperationFunc{
			logical.ListOperation: b.pathRequestList,
		},
	}
}

func pathListRequests(b *backend) *framework.Path {
	return &framework.Path{
		Pattern: "requests/" + framework.GenericNameRegex("name") + "/?$",
		Fields: map[string]*framework.FieldSchema{
			"name": {
				Type:        framework.TypeString,
				Description: "Name of role for sr.",
				Required:    true,
			},
		},
		Callbacks: map[logical.Operation]framework.OperationFunc{
			logical.ListOperation: b.pathRequestList,
		},
	}
}

func (b *backend) pathRequestRead(ctx context.Context, r *logical.Request, d *framework.FieldData) (*logical.Response, error) {
	roleName := d.Get("name").(string)
	nonce := d.Get("nonce").(string)

	sr, err := b.request(ctx, r.Storage, roleName, nonce)
	if err != nil {
		return nil, err
	} else if sr == nil {
		return nil, nil
	}

	resp := &logical.Response{
		Data: map[string]interface{}{
			"nonce":                nonce,
			"expires_at":           sr.ExpiresAt,
			"requester_id":         sr.RequesterID,
			"approver_ids":         sr.ApproverIDs,
			"bound_approver_ids":   sr.BoundApproverIDs,
			"bound_approver_roles": sr.BoundApproverRoles,
		},
	}

	return resp, nil
}

func (b *backend) pathRequestDelete(ctx context.Context, r *logical.Request, d *framework.FieldData) (*logical.Response, error) {

	roleName := d.Get("name").(string)
	nonce := d.Get("nonce").(string)

	if err := b.requestAccessor.delete(ctx, r.Storage, path.Join(roleName, nonce)); err != nil {
		return nil, err
	}

	return nil, nil
}

func (b *backend) pathRequestExistenceCheck(ctx context.Context, r *logical.Request, d *framework.FieldData) (bool, error) {
	roleName := d.Get("name").(string)
	nonce := d.Get("nonce").(string)

	request, err := b.request(ctx, r.Storage, roleName, nonce)
	if err != nil {
		return false, err
	}

	return request != nil, nil
}

func (b *backend) pathRequestList(ctx context.Context, r *logical.Request, d *framework.FieldData) (*logical.Response, error) {

	roleName := d.Get("name").(string)
	requests, err := b.requestAccessor.list(ctx, r.Storage, roleName)
	if err != nil {
		return nil, err
	}
	return logical.ListResponse(requests), nil
}

func (b *backend) pathRequestCreateUpdate(ctx context.Context, r *logical.Request, d *framework.FieldData) (*logical.Response, error) {

	roleName := d.Get("name").(string)
	role, err := b.role(ctx, r.Storage, roleName)
	if err != nil {
		return nil, err
	}
	if role == nil {
		return logical.ErrorResponse(fmt.Sprintf("role %q does not exists", roleName)), nil
	}

	reason := d.Get("reason").(string)
	if reason == "" {
		return logical.ErrorResponse("field 'reason' is mandatory"), nil
	}

	nonce, err := uuid.GenerateUUID()
	if err != nil {
		return logical.ErrorResponse("failed to create nonce" + err.Error()), nil
	}

	cfg, err := b.config(ctx, r.Storage)
	if err != nil {
		return logical.ErrorResponse("could not find config: " + err.Error()), nil
	}

	requesterID, err := b.validateBoundRequesterIDs(ctx, r, role)
	if err != nil {
		return logical.ErrorResponse("failed to validate bound_requester_ids: " + err.Error()), nil
	}

	if err = b.verifyCallerRoles(ctx, r, role.BoundRequesterRoles); err != nil {
		return logical.ErrorResponse("failed to validate bound_requester_roles: " + err.Error()), nil
	}

	request := &requestStorageEntry{
		Nonce:               nonce,
		ExpiresAt:           time.Now().Add(cfg.ApprovalTTL),
		RequesterID:         requesterID,
		BoundRequesterIDs:   role.BoundRequesterIDs,
		BoundRequesterRoles: role.BoundRequesterRoles,
		BoundApproverIDs:    role.BoundApproverIDs,
		BoundApproverRoles:  role.BoundApproverRoles,
		MinApprovers:        role.MinApprovers,
		ApproverIDs:         []string{},
	}

	if err = b.requestAccessor.put(ctx, r.Storage, request, roleName, nonce); err != nil {
		return nil, errors.Wrapf(err, "failed to store request")
	}

	resp := b.Secret(secretTypeApprovedSecretRequest).Response(map[string]interface{}{
		"nonce":                 nonce,
		"ttl":                   fmt.Sprintf("%s", cfg.ApprovalTTL),
		"min_approvers":         role.MinApprovers,
		"bound_requester_ids":   role.BoundRequesterIDs,
		"bound_requester_roles": role.BoundRequesterRoles,
		"bound_approver_ids":    role.BoundApproverIDs,
		"bound_approver_roles":  role.BoundApproverRoles,
		"secret_path":           role.SecretPath,
		"requester_id":          requesterID,
	}, map[string]interface{}{
		"nonce": nonce,
		"name":  roleName,
	})

	resp.Secret.TTL = cfg.ApprovalTTL
	resp.Secret.MaxTTL = cfg.ApprovalTTL

	attach := slack.Attachment{}
	attach.AddField(slack.Field{Value: fmt.Sprintf("```vault-helper approved-secret-approve -role %s -nonce %s```", roleName, nonce)})
	attach.AddField(slack.Field{Value: fmt.Sprintf("```vault-helper approved-secret-issue -role %s -nonce %s```", roleName, nonce)})
	attach.AddField(slack.Field{Value: fmt.Sprintf("*Reason:* %s", reason)})

	payload := slack.Payload{
		Text:        fmt.Sprintf("%s requests role *%q*", requesterID, roleName),
		Username:    "Vault Approved Secrets Plugin",
		Attachments: []slack.Attachment{attach},
	}

	for _, c := range role.NotifySlackChannels {
		payload.Channel = c
		errs := slack.Send(cfg.SlackWebhookURL, "", payload)
		if len(errs) > 0 {
			return logical.ErrorResponse(fmt.Sprintf("failed to send Slack notification to channel %q: %s", c, errs[0])), nil
		}
	}

	return resp, nil
}

func (b *backend) validateBoundRequesterIDs(ctx context.Context, r *logical.Request, role *roleStorageEntry) (string, error) {

	cfg, err := b.config(ctx, r.Storage)
	if err != nil {
		return "", errors.New("could not find config: " + err.Error())
	}

	callerID, err := b.getCallerIdentity(r, cfg.IdentityTemplate)
	if err != nil {
		return "", errors.New("failed to get caller's identity: " + err.Error())
	}

	if len(role.BoundRequesterIDs) > 0 {
		approved := false
		for _, a := range role.BoundRequesterIDs {
			if strings.ToLower(callerID) == strings.ToLower(a) {
				approved = true
				break
			}
		}
		if !approved {
			return "", errors.New(fmt.Sprintf("%q not in %s", callerID, role.BoundRequesterIDs))
		}
	}

	return callerID, nil
}

type requestStorageEntry struct {
	Nonce               string    `json:"nonce"`
	ExpiresAt           time.Time `json:"expires_at"`
	RequesterID         string    `json:"requester_id"`
	BoundRequesterIDs   []string  `json:"bound_requester_ids"`
	BoundRequesterRoles []string  `json:"bound_requester_roles"`
	BoundApproverIDs    []string  `json:"bound_approver_ids"`
	BoundApproverRoles  []string  `json:"bound_approver_roles"`
	MinApprovers        int       `json:"min_approvers"`
	ApproverIDs         []string  `json:"approver_ids"`
}
