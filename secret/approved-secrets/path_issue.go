package main

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"path"
	"regexp"
	"strings"
	"time"

	"github.com/hashicorp/vault/sdk/framework"
	"github.com/hashicorp/vault/sdk/logical"
	"github.com/pkg/errors"
)

func pathIssue(b *backend) *framework.Path {
	return &framework.Path{
		Pattern: "issue/" + framework.GenericNameRegex("name") + framework.OptionalParamRegex("nonce"),
		Fields: map[string]*framework.FieldSchema{
			"name": {
				Type:        framework.TypeString,
				Description: "Name of role of approved request.",
				Required:    true,
			},
			"nonce": {
				Type:        framework.TypeString,
				Description: "Nonce generated by approved request.",
				Required:    true,
			},
		},
		ExistenceCheck: b.pathIssueExistenceCheck,
		Callbacks: map[logical.Operation]framework.OperationFunc{
			logical.DeleteOperation: b.pathIssueDelete,
			logical.ReadOperation:   b.pathIssueRead,
			logical.CreateOperation: b.pathIssueCreateUpdate,
			logical.UpdateOperation: b.pathIssueCreateUpdate,
		},
	}
}

func (b *backend) pathIssueExistenceCheck(ctx context.Context, r *logical.Request, d *framework.FieldData) (bool, error) {

	name := d.Get("name").(string)
	nonce := d.Get("nonce").(string)
	issue, err := b.issue(ctx, r.Storage, name, nonce)
	if err != nil {
		return false, err
	}

	return issue != nil, nil
}

func (b *backend) pathIssueDelete(ctx context.Context, r *logical.Request, d *framework.FieldData) (*logical.Response, error) {

	name := d.Get("name").(string)
	nonce := d.Get("nonce").(string)
	if err := b.issueAccessor.delete(ctx, r.Storage, path.Join(name, nonce)); err != nil {
		return nil, err
	}

	return nil, nil
}

func pathListIssue(b *backend) *framework.Path {
	return &framework.Path{
		Pattern: "issue/" + framework.GenericNameRegex("name") + "/?$",
		Fields: map[string]*framework.FieldSchema{
			"name": {
				Type:        framework.TypeString,
				Description: "Name of role for issue.",
				Required:    true,
			},
		},
		Callbacks: map[logical.Operation]framework.OperationFunc{
			logical.ListOperation: b.pathIssueList,
		},
	}
}

func pathListIssues(b *backend) *framework.Path {
	return &framework.Path{
		Pattern: "issues/" + framework.GenericNameRegex("name") + "/?$",
		Fields: map[string]*framework.FieldSchema{
			"name": {
				Type:        framework.TypeString,
				Description: "Name of role for issue.",
				Required:    true,
			},
		},
		Callbacks: map[logical.Operation]framework.OperationFunc{
			logical.ListOperation: b.pathIssueList,
		},
	}
}

func (b *backend) pathIssueList(ctx context.Context, r *logical.Request, d *framework.FieldData) (*logical.Response, error) {

	name := d.Get("name").(string)
	requests, err := b.issueAccessor.list(ctx, r.Storage, name)
	if err != nil {
		return nil, err
	}
	return logical.ListResponse(requests), nil
}

func (b *backend) pathIssueRead(ctx context.Context, r *logical.Request, d *framework.FieldData) (*logical.Response, error) {

	name := d.Get("name").(string)
	nonce := d.Get("nonce").(string)
	issue, err := b.issue(ctx, r.Storage, name, nonce)
	if err != nil {
		return nil, err
	}
	if issue == nil {
		return nil, nil
	}

	resp := &logical.Response{
		Data: map[string]interface{}{
			"nonce":        nonce,
			"expires_at":   issue.ExpiresAt,
			"issuer_id":    issue.IssuerID,
			"approver_ids": issue.ApproverIDs,
		},
	}

	return resp, nil
}

func (b *backend) pathIssueCreateUpdate(ctx context.Context, r *logical.Request, d *framework.FieldData) (*logical.Response, error) {

	roleName := d.Get("name").(string)
	role, err := b.role(ctx, r.Storage, roleName)
	if err != nil {
		return nil, err
	} else if role == nil {
		return logical.ErrorResponse(fmt.Sprintf("role %q does not exists", roleName)), nil
	}

	for _, field := range role.SecretRequiredFields {
		if _, ok := d.GetOk(field); !ok {
			return logical.ErrorResponse(fmt.Sprintf("missing required field %q", field)), nil
		}
	}

	nonce := d.Get("nonce").(string)
	sr, err := b.request(ctx, r.Storage, roleName, nonce)
	if err != nil {
		return nil, err
	}
	if sr == nil {
		return logical.ErrorResponse(fmt.Sprintf("request does not exists for role %q with nonce %q (expired or already issued?)", roleName, nonce)), nil
	}

	cfg, err := b.config(ctx, r.Storage)
	if err != nil {
		return logical.ErrorResponse("could not find config: " + err.Error()), nil
	}

	issuerID, err := b.getCallerIdentity(r, cfg.IdentityTemplate)
	if err != nil {
		return logical.ErrorResponse("failed to get caller's identity: " + err.Error()), nil
	}

	if strings.ToLower(issuerID) != strings.ToLower(sr.RequesterID) {
		return logical.ErrorResponse("only requester %q is allowed to issue secret", sr.RequesterID), nil
	}

	if len(sr.ApproverIDs) < sr.MinApprovers {
		return logical.ErrorResponse("request must be approved by at least %d (got %d)", sr.MinApprovers, len(sr.ApproverIDs)), nil
	}

	if role.ExclusiveLease {
		leases, err := r.Storage.List(ctx, "issue/"+roleName+"/")
		if err != nil {
			return nil, err
		}
		if len(leases) > 0 {
			issue, err := b.issue(ctx, r.Storage, roleName, leases[0])
			if err != nil {
				return logical.ErrorResponse("failed to read lease: \n", issue.ExpiresAt), nil
			}

			if time.Now().After(issue.ExpiresAt) {
				err := r.Storage.Delete(ctx, path.Join("issue", roleName, nonce))
				if err != nil {
					return logical.ErrorResponse(fmt.Sprintf("failed to delete issue for role %q with nonce %q: %s", roleName, nonce, err.Error())), nil
				}
			}

			return nil, logical.CodedError(http.StatusForbidden, fmt.Sprintf("role's secret exclusive_lease is set, but active lease found:\n\nnonce: %s\nexpiry: %s", leases[0], issue.ExpiresAt))
		}
	}

	config, err := b.config(ctx, r.Storage)
	if err != nil {
		return logical.ErrorResponse("could not find config"), nil
	}

	clt, err := newVaultClient(ctx, config.VaultAddr, config.VaultToken)
	if err != nil {
		return logical.ErrorResponse(fmt.Sprintf("failed to create vault client: %s", err)), nil
	}

	tokenData := map[string]interface{}{"policies": cfg.VaultPolicies}
	secret, err := createClientToken(clt, tokenData, issuerID)
	if err != nil {
		return logical.ErrorResponse("could not create Vault client token: " + err.Error()), nil
	}

	clt.SetToken(secret.Auth.ClientToken)

	var ttl time.Duration
	if rawTTL, ok := d.GetOk("ttl"); ok {
		ttl = time.Second * time.Duration(rawTTL.(int))
	} else {
		ttl = role.SecretTTL
	}

	var ttlWarning string
	if ttl > role.SecretMaxTTL {
		ttlWarning = fmt.Sprintf("Specified ttl is greater than role-secret's max TTL, capped to max TTL: %s", role.SecretMaxTTL)
		ttl = role.SecretMaxTTL
	}

	if strings.ToUpper(role.SecretPathMethod) == "POST" {
		data := d.Raw
		data["ttl"] = ttl / time.Second
		for k, v := range b.applyIdentityTemplateToSecretData(r, role.SecretData) {
			data[k] = v
		}

		if role.SecretType == "vault-token" {
			secret, err = createClientToken(clt, data, issuerID)
		} else {
			secret, err = clt.Logical().Write(role.SecretPath, data)
		}
	} else {
		secret, err = clt.Logical().Read(role.SecretPath)
	}
	if err != nil {
		return logical.ErrorResponse(fmt.Sprintf("failed to %s secret %q: %s", role.SecretPathMethod, role.SecretPath, err)), nil
	}

	data := secret.Data
	if role.SecretType == "vault-token" { // Got a vault token
		bytes, _ := json.Marshal(*secret.Auth)
		data = map[string]interface{}{}
		json.Unmarshal(bytes, &data)
	}

	resp := b.Secret(secretTypeApprovedSecretIssue).Response(data, map[string]interface{}{
		"nonce": nonce,
		"name":  roleName,
	})

	if ttlWarning != "" {
		resp.AddWarning(ttlWarning)
	}

	issue := &issueStorageEntry{
		Nonce:       nonce,
		ExpiresAt:   time.Now().Add(ttl),
		IssuerID:    sr.RequesterID,
		ApproverIDs: sr.ApproverIDs,
	}

	if err = b.issueAccessor.put(ctx, r.Storage, issue, roleName, nonce); err != nil {
		return nil, errors.Wrapf(err, "failed to store request")
	}

	resp.Secret.TTL = ttl
	resp.Secret.MaxTTL = ttl

	err = r.Storage.Delete(ctx, path.Join("request", roleName, nonce))
	if err != nil {
		resp.AddWarning(fmt.Sprintf("failed to delete request for role %q with nonce %q: %s", roleName, nonce, err.Error()))
	}

	return resp, nil
}

func (b *backend) applyIdentityTemplateToSecretData(r *logical.Request, secretData map[string]interface{}) map[string]interface{} {

	data := map[string]interface{}{}
	for k, v := range secretData {

		switch casted := v.(type) {
		case string:
			data[k] = v
			matched, _ := regexp.MatchString(`^{{.+?}}$`, casted)
			if matched && r.EntityID != "" {
				res, err := framework.PopulateIdentityTemplate(casted, r.EntityID, b.System())
				if err != nil {
					continue
				}
				data[k] = res
			}
		case map[string]interface{}:
			data[k] = b.applyIdentityTemplateToSecretData(r, casted)
		default:
			data[k] = v
		}
	}

	return data
}

type issueStorageEntry struct {
	Nonce       string    `json:"nonce"`
	ExpiresAt   time.Time `json:"expires_at"`
	IssuerID    string    `json:"issuer_id"`
	ApproverIDs []string  `json:"approver_ids"`
}
