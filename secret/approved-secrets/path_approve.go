package main

import (
	"context"
	"fmt"
	"path"
	"strings"

	"github.com/hashicorp/vault/sdk/framework"
	"github.com/hashicorp/vault/sdk/logical"
	"github.com/pkg/errors"
)

func pathApprove(b *backend) *framework.Path {
	return &framework.Path{
		Pattern: "approve/" + framework.GenericNameRegex("name"),
		Fields: map[string]*framework.FieldSchema{
			"name": {
				Type:        framework.TypeString,
				Description: "Name of role for approve.",
				Required:    true,
			},
			"nonce": {
				Type:        framework.TypeString,
				Description: "Nonce generated by request.",
				Required:    true,
			},
		},
		Callbacks: map[logical.Operation]framework.OperationFunc{
			logical.CreateOperation: b.pathApproveCreateUpdate,
			logical.UpdateOperation: b.pathApproveCreateUpdate,
		},
	}
}

func (b *backend) pathApproveCreateUpdate(ctx context.Context, r *logical.Request, d *framework.FieldData) (*logical.Response, error) {

	name := d.Get("name").(string)
	role, err := b.role(ctx, r.Storage, name)
	if err != nil {
		return nil, err
	}
	if role == nil {
		return logical.ErrorResponse(fmt.Sprintf("role %q does not exists", name)), nil
	}

	nonce := d.Get("nonce").(string)

	sr, err := b.request(ctx, r.Storage, name, nonce)
	if err != nil {
		return nil, err
	}
	if sr == nil {
		return logical.ErrorResponse(fmt.Sprintf("request does not exists for role %q with nonce %q (expired or already issued?)", name, nonce)), nil
	}

	approverID, err := b.validateBoundApproverIDs(ctx, r, sr)
	if err != nil {
		return logical.ErrorResponse("failed to validate bound_approver_ids: " + err.Error()), nil
	}

	if err = b.verifyCallerRoles(ctx, r, role.BoundApproverRoles); err != nil {
		return logical.ErrorResponse("failed to validate bound_requester_roles: " + err.Error()), nil
	}

	sr.ApproverIDs = append(sr.ApproverIDs, strings.ToLower(approverID))
	storagePath := path.Join("request", name, strings.ToLower(nonce))
	entry, err := logical.StorageEntryJSON(storagePath, &sr)
	if err != nil {
		return nil, err
	}
	if entry == nil {
		return nil, fmt.Errorf("failed to create storage entry for request for role %q with nonce %q", name, nonce)
	}
	if err = r.Storage.Put(ctx, entry); err != nil {
		return nil, err
	}

	data := map[string]interface{}{
		"nonce":                 sr.Nonce,
		"expires_at":            sr.ExpiresAt,
		"requester_id":          sr.RequesterID,
		"approver_ids":          sr.ApproverIDs,
		"min_approvers":         sr.MinApprovers,
		"bound_requester_ids":   sr.BoundRequesterIDs,
		"bound_requester_roles": sr.BoundRequesterRoles,
		"bound_approver_ids":    sr.BoundApproverIDs,
		"bound_approver_roles":  sr.BoundApproverRoles,
	}

	return &logical.Response{Data: data}, nil
}

func (b *backend) validateBoundApproverIDs(ctx context.Context, r *logical.Request, sr *requestStorageEntry) (string, error) {

	cfg, err := b.config(ctx, r.Storage)
	if err != nil {
		return "", errors.New("could not find config: " + err.Error())
	}

	callerID, err := b.getCallerIdentity(r, cfg.IdentityTemplate)
	if err != nil {
		return "", errors.New("failed to get caller's identity: " + err.Error())
	}

	if strings.ToLower(callerID) == strings.ToLower(sr.RequesterID) {
		return "", errors.New("cannot approve your own request")
	}

	if len(sr.BoundApproverIDs) > 0 {
		approved := false
		for _, a := range sr.BoundApproverIDs {
			if strings.ToLower(callerID) == strings.ToLower(a) {
				approved = true
				break
			}
		}
		if !approved {
			return "", errors.New(fmt.Sprintf("%q not in %s", callerID, sr.BoundApproverIDs))
		}
	}

	for _, a := range sr.ApproverIDs {
		if strings.ToLower(callerID) == strings.ToLower(a) {
			return "", errors.New("already approved by you")
		}
	}

	return callerID, nil
}
